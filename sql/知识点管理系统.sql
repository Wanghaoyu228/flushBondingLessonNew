/*
SQLyog Ultimate v11.13 (64 bit)
MySQL - 5.5.37 : Database - flushbondinglesson
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`flushbondinglesson` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_bin */;

USE `flushbondinglesson`;

/*Table structure for table `knowledge` */

DROP TABLE IF EXISTS `knowledge`;

CREATE TABLE `knowledge` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) COLLATE utf8_bin NOT NULL,
  `content` longtext COLLATE utf8_bin,
  `sortNum` int(11) NOT NULL,
  `level` varchar(50) COLLATE utf8_bin NOT NULL,
  `pid` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

/*Data for the table `knowledge` */

insert  into `knowledge`(`id`,`name`,`content`,`sortNum`,`level`,`pid`) values (22,'数据结构','<div class=\"para\" label-module=\"para\">第1章 准备旅行<br>　　第2章 面向对象编程导论<br>　　第3章 链式数据表示<br>　　第4章 递归<br>　　第5章 模块化与数据抽象<br>　　第6章 线性数据结构――堆栈与队列<br>　　第7章 链表、字符串和动态内存分配<br>　　第8章 树与图<br>　　第9章 散列和Table ADT<br>　　第10章 排序<br>　　附录A JAVATM要点回顾<br>　　附录B 表示效率的语言<br>　　附录C 软件工程概念</div>',1,'1',0),(23,'树的定义','<div id=\"arc-body\">之前介绍的所有的数据结构都是线性存储结构。本章所介绍的树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。\r\n<div style=\"text-align: center;\">\r\n<img alt=\"\" src=\"http://data.biancheng.net/uploads/allimg/170830/2-1FS0094003158.png\" style=\"width: 579px; height: 244px;\"></div>\r\n<span style=\"text-align: center;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>\r\n<div style=\"text-align: center;\">\r\n<span style=\"text-align: center;\">&nbsp; &nbsp; &nbsp; &nbsp;(A) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(B)&nbsp;</span></div>\r\n<div style=\"text-align: center;\">\r\n<u><a href=\"/view/200.html\" target=\"_blank\">图</a></u> 1 树的示例</div>\r\n<br>\r\n图 1(A) 是使用树结构存储的集合 {A,B,C,D,E,F,G,H,I,J,K,L,M} 的示意图。对于数据 A 来说，和数据 B、C、D 有关系；对于数据 B 来说，和 E、F 有关系。这就是<span style=\"color:#008000;\">“一对多”</span>的关系。<br>\r\n<br>\r\n将具有“一对多”关系的集合中的数据元素按照图 1（A）的形式进行存储，整个存储形状在逻辑结构上看，类似于实际生活中倒着的树（图 1（B）倒过来），所以称这种存储结构为<span style=\"color:#008000;\">“树型”</span>存储结构。\r\n<h2>\r\n树的结点</h2>\r\n<span style=\"color:#008000;\">结点</span>：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点；<br>\r\n<br>\r\n<span style=\"color:#008000;\">父结点（双亲结点）、子结点和兄弟结点</span>：对于图 1（A）中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称<span style=\"color:#008000;\">“孩子结点”</span>）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。<br>\r\n<br>\r\n<span style=\"color:#008000;\">树根结点（简称“根结点”）</span>：每一个非空树都有且只有一个被称为根的结点。图 1（A）中，结点A就是整棵树的根结点。<br>\r\n<div class=\"info-box\">\r\n树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</div>\r\n<span style=\"color:#008000;\">叶子结点</span>：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如图 1（A）中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。\r\n<h2>\r\n子树和空树</h2>\r\n<span style=\"color:#008000;\">子树</span>：如图 1（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。<br>\r\n<blockquote>\r\n<p>\r\n<span style=\"color:#b22222;\">注意：</span>单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。</p>\r\n</blockquote>\r\n知道了子树的概念后，<span style=\"color:#b22222;\">树也可以这样定义：树是由根结点和若干棵子树构成的</span>。<br>\r\n<br>\r\n<span style=\"color:#008000;\">空树</span>：如果集合本身为空，那么构成的树就被称为空树。<span style=\"color:#b22222;\">空树中没有结点。</span><br>\r\n<div class=\"info-box\">\r\n补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，图 1（A）中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。</div>\r\n<h2>\r\n结点的度和层次</h2>\r\n<span style=\"color:#b22222;\">对于一个结点，拥有的子树数（结点有多少分支）称为结点的</span><span style=\"color:#008000;\">度（Degree）</span>。例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。<br>\r\n<div class=\"info-box\">\r\n一棵树的度是树内各结点的度的最大值。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。</div>\r\n<span style=\"color:#008000;\">结点的层次</span>：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。\r\n<div class=\"info-box\">\r\n一棵树的深度（高度）是树中结点所在的最大的层次。图 1（A）树的深度为 4。</div>\r\n如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。\r\n<h2>\r\n有序树和无序树</h2>\r\n如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为<span style=\"color:#008000;\">有序树</span>；反之称为<span style=\"color:#008000;\">无序树</span>。<br>\r\n<div class=\"info-box\">\r\n在有序树中，一个结点最左边的子树称为<span style=\"color:#008000;\">\"第一个孩子\"</span>，最右边的称为<span style=\"color:#008000;\">\"最后一个孩子\"</span>。</div>\r\n<p>\r\n拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。</p>\r\n<h2>\r\n森林</h2>\r\n<span style=\"color:#b22222;\">由 m（m &gt;= 0）个互不相交的树组成的集合被称为</span><span style=\"color:#008000;\">森林</span>。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。<br>\r\n<br>\r\n前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：\r\n<div class=\"info-box\">\r\nTree =（root,F）</div>\r\n其中，root 表示树的根结点，F 表示由 m（m &gt;= 0）棵树组成的森林。\r\n<h2>\r\n树的表示方法</h2>\r\n除了图 1（A）表示树的方法外，还有其他表示方法：\r\n<div style=\"text-align: center;\">\r\n<img alt=\"\" src=\"http://data.biancheng.net/uploads/allimg/170830/2-1FS00952413Y.png\" style=\"width: 400px; height: 245px;\"></div>\r\n<div>\r\n&nbsp;</div>\r\n<div style=\"text-align: center;\">\r\n<br>\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （A） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （B）</div>\r\n<div style=\"text-align: center;\">\r\n图2 树的表示形式<br>\r\n&nbsp;</div>\r\n图 2（A）是以嵌套的集合的形式表示的<span style=\"color:#b22222;\">（集合之间绝不能相交，即图中任意两个圈不能相交）</span>。<br>\r\n<br>\r\n图 2（B）使用的是<span style=\"color:#008000;\">凹入表示法</span>（了解即可），表示方式是：最长条为根结点，相同长度的表示在同一层次。例如 B、C、D 长度相同，都为 A 的子结点，E 和 F 长度相同，为 B 的子结点，K 和 L 长度相同，为 E 的子结点，依此类推。<br>\r\n<br>\r\n最常用的表示方法是使用<u><a href=\"/view/189.html\" target=\"_blank\">广义表</a></u>的方式。图 1（A）用广义表表示为：\r\n<div class=\"info-box\">\r\n(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )</div>\r\n<h2>\r\n总结</h2>\r\n树型存储结构类似于家族的族谱，各个结点之间也同样可能具有父子、兄弟、表兄弟的关系。本节中，要重点理解树的根结点和子树的定义，同时要会计算树中各个结点的度和层次，以及树的深度。<br>\r\n</div>',2,'2',22),(24,'图的定义','<div id=\"arc-body\">我们知道，数据之间的关系有 3 种，分别是 \"一对一\"、\"一对多\" 和 \"多对多\"，前两种关系的数据可分别用<u><a href=\"/view/157.html\" target=\"_blank\">线性表</a></u>和<u><a href=\"/view/23.html\" target=\"_blank\">树</a></u>结构存储，本节学习存储具有\"多对多\"逻辑关系数据的结构——<span style=\"color:#008000;\">图</span>存储结构。\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"\" src=\"http://data.biancheng.net/uploads/allimg/190103/2-1Z1032054241T.gif\"><br>\r\n图 1 图存储结构示意图</div>\r\n<br>\r\n图 1 所示为存储 V1、V2、V3、V4 的图结构，从图中可以清楚的看出数据之间具有的\"多对多\"关系。例如，V1 与 V4 和 V2 建立着联系，V4 与 V1 和 V3 建立着联系，以此类推。<br>\r\n<br>\r\n与<u><a href=\"/view/160.html\" target=\"_blank\">链表</a></u>不同，图中存储的各个数据元素被称为顶点（而不是节点）。拿图 1 来说，该图中含有 4 个顶点，分别为顶点 V1、V2、V3 和 V4。<br>\r\n<p class=\"info-box\">\r\n图存储结构中，习惯上用 Vi 表示图中的顶点，且所有顶点构成的集合通常用 V 表示，如图 1 中顶点的集合为 V={V1,V2,V3,V4}。</p>\r\n<br>\r\n注意，图 1 中的图仅是图存储结构的其中一种，数据之间 \"多对多\" 的关系还可能用如图 2 所示的图结构表示：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"\" src=\"http://data.biancheng.net/uploads/allimg/190103/2-1Z1032055151L.gif\"><br>\r\n图 2 有向图示意图</div>\r\n<br>\r\n可以看到，各个顶点之间的关系并不是\"双向\"的。比如，V4 只与 V1 存在联系（从 V4 可直接找到 V1），而与 V3 没有直接联系；同样，V3 只与 V4 存在联系（从 V3 可直接找到 V4），而与 V1 没有直接联系，以此类推。<br>\r\n<br>\r\n因此，图存储结构可细分两种表现类型，分别为<span style=\"color:#008000;\">无向图</span>（图 1）和<span style=\"color:#008000;\">有向图</span>（图 2）。<br>\r\n<h2>\r\n图的基本常识</h2>\r\n<h4>\r\n弧头和弧尾</h4>\r\n有向图中，无箭头一端的顶点通常被称为\"<span style=\"color:#008000;\">初始点</span>\"或\"<span style=\"color:#008000;\">弧尾</span>\"，箭头直线的顶点被称为\"<span style=\"color:#008000;\">终端点</span>\"或\"<span style=\"color:#008000;\">弧头</span>\"。<br>\r\n<h4>\r\n入度和出度</h4>\r\n对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的<span style=\"color:#008000;\">入度（InDegree，记为 ID(V)）</span>；箭头远离 V 的弧的数量为 V 的<span style=\"color:#008000;\">出度（OutDegree，记为OD(V)）</span>。拿图 2 中的顶点 V1来说，该顶点的入度为 1，出度为 2（该顶点的度为 3）。<br>\r\n<h4>\r\n(V1,V2) 和 &lt;V1,V2&gt; 的区别</h4>\r\n无向图中描述两顶点（V1 和 V2）之间的关系可以用 (V1,V2) 来表示，而有向图中描述从 V1 到 V2 的\"单向\"关系用 &lt;V1,V2&gt; 来表示。<br>\r\n<br>\r\n由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2) 还可以用来表示无向图中连接 V1 和 V2 的线，又称为<span style=\"color:#008000;\">边</span>；同样，&lt;V1,V2&gt; 也可用来表示有向图中从 V1 到 V2 带方向的线，又称为<span style=\"color:#008000;\">弧</span>。<br>\r\n<h4>\r\n集合 VR 的含义</h4>\r\n并且，图中习惯用 VR 表示图中所有顶点之间关系的集合。例如，图 1 中无向图的集合 VR={(v1,v2),(v1,v4),(v1,v3),(v3,v4)}，图 2 中有向图的集合 VR={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。<br>\r\n<h4>\r\n路径和回路</h4>\r\n无论是无向图还是有向图，从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条<span style=\"color:#008000;\">路径</span>。如果路径中第一个顶点和最后一个顶点相同，则此路径称为\"<span style=\"color:#008000;\">回路</span>\"（或\"环\"）。<br>\r\n<br>\r\n并且，若路径中各顶点都不重复，此路径又被称为\"<span style=\"color:#008000;\">简单路径</span>\"；同样，若回路中的顶点互不重复，此回路被称为\"<span style=\"color:#008000;\">简单回路</span>\"（或简单环）。<br>\r\n<br>\r\n拿图 1 来说，从 V1 存在一条路径还可以回到 V1，此路径为 {V1,V3,V4,V1}，这是一个回路（环），而且还是一个简单回路（简单环）。<br>\r\n<p class=\"info-box\">\r\n在有向图中，每条路径或回路都是有方向的。</p>\r\n<h4>\r\n权和网的含义</h4>\r\n在某些实际场景中，图中的每条边（或弧）会赋予一个实数来表示一定的含义，这种与边（或弧）相匹配的实数被称为\"<span style=\"color:#008000;\">权</span>\"，而带权的图通常称为<span style=\"color:#008000;\">网</span>。如图 3 所示，就是一个网结构：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"\" src=\"http://data.biancheng.net/uploads/allimg/190103/2-1Z10321001LT.gif\"><br>\r\n图 3 带权的图存储结构</div>\r\n<br>\r\n<span style=\"color:#008000;\">子图</span>：指的是由图中一部分顶点和边构成的图，称为原图的子图。<br>\r\n<h2>\r\n图存储结构的分类</h2>\r\n根据不同的特征，图又可分为<span style=\"color:#008000;\">完全图</span>，<span style=\"color:#008000;\"><u><a href=\"/view/201.html\" target=\"_blank\">连通图</a></u></span>、<span style=\"color:#008000;\">稀疏图</span>和<span style=\"color:#008000;\">稠密图</span>：<br>\r\n<ul>\r\n<li>\r\n完全图：若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为<span style=\"color:#008000;\">完全图</span>（如图 4a)）。同时，满足此条件的有向图则称为<span style=\"color:#008000;\">有向完全图</span>（图 4b)）。\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"\" src=\"http://data.biancheng.net/uploads/allimg/190103/2-1Z103210110O8.gif\"><br>\r\n图 4 完全图示意图</div>\r\n<p class=\"info-box\">\r\n具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。</p>\r\n</li>\r\n<li>\r\n稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为\"稀疏图\"；反之，则称此图为\"稠密图\"。\r\n<p class=\"info-box\">\r\n稀疏和稠密的判断条件是：e&lt;nlogn，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。</p>\r\n</li>\r\n</ul>\r\n<br>\r\n有关连通图的相关知识，后续专门有一篇文章做详细介绍。<br>\r\n</div>',3,'2',22),(25,'线性表','<div id=\"arc-body\">通过前面的学习我们知道，具有“一对一”逻辑关系的数据，最佳的存储方式是使用线性表。那么，什么是线性表呢？<br>\r\n<br>\r\n<font color=\"#008000\">线性表，</font>全名为<font color=\"#008000\">线性存储结构</font>。使用线性表存储数据的方式可以这样理解，即<span style=\"color:#b22222;\">“把所有数据</span><span style=\"color: rgb(178, 34, 34);\">用一根线儿</span><span style=\"color:#b22222;\"><u><a href=\"/view/175.html\" target=\"_blank\">串</a></u>起来，再存储到物理空间中”。</span>\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"&quot;一对一&quot;逻辑关系的数据\" src=\"/uploads/allimg/181120/1-1Q120214QJ63.gif\"><br>\r\n<u><a href=\"/view/200.html\" target=\"_blank\">图</a></u> 1 \"一对一\"逻辑关系的数据</div>\r\n<br>\r\n如图 1 所示，这是一组具有“一对一”关系的数据，我们接下来采用线性表将其储存到物理空间中。<br>\r\n<br>\r\n首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"\" src=\"/uploads/allimg/181120/1-1Q12021551W22.gif\"><br>\r\n图 2 数据的\"线性\"结构</div>\r\n<br>\r\n图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"两种线性存储结构\" src=\"/uploads/allimg/181120/1-1Q120215009361.gif\"><br>\r\n图 3 两种线性存储结构</div>\r\n<br>\r\n图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样）。因此可以认定，这两种存储方式都是正确的。<br>\r\n<br>\r\n<span style=\"color:#b22222;\">将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为</span><span style=\"color:#008000;\">线性存储结构（简称线性表）</span><span style=\"color:#b22222;\">。</span><br>\r\n<br>\r\n使用线性表存储的数据，如同向<u><a href=\"/view/181.html\" target=\"_blank\">数组</a></u>中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。<br>\r\n<h2>\r\n顺序存储结构和链式存储结构</h2>\r\n图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：\r\n<ol>\r\n<li>\r\n如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为<span style=\"color:#008000;\">顺序存储结构</span>（简称<span style=\"color:#008000;\"><u><a href=\"/view/158.html\" target=\"_blank\">顺序表</a></u></span>）；</li>\r\n<li>\r\n如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为<span style=\"color:#008000;\">链式存储结构</span>（简称<span style=\"color:#008000;\"><u><a href=\"/view/160.html\" target=\"_blank\">链表</a></u></span>）；</li>\r\n</ol>\r\n<br>\r\n也就是说，<span style=\"color:#b22222;\">线性表存储结构可细分为顺序存储结构和链式存储结构。</span><br>\r\n<h2>\r\n线性表常用术语</h2>\r\n数据结构中，一组数据中的每个个体被称为“<span style=\"color:#008000;\">数据元素</span>”（简称“<span style=\"color:#008000;\">元素</span>”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据钟的一个元素。<br>\r\n<br>\r\n另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：\r\n<ul>\r\n<li>\r\n某一元素的左侧相邻元素称为“<span style=\"color:#008000;\">直接前驱</span>”，位于此元素左侧的所有元素都统称为“<span style=\"color:#008000;\">前驱元素</span>”；</li>\r\n<li>\r\n某一元素的右侧相邻元素称为“<span style=\"color:#008000;\">直接后继</span>”，位于此元素右侧的所有元素都统称为“<span style=\"color:#008000;\">后继元素</span>”；</li>\r\n</ul>\r\n<br>\r\n以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：<br>\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"前驱和后继\" src=\"/uploads/allimg/181120/1-1Q1202152464R.gif\"><br>\r\n图 4 前驱和后继</div>\r\n</div>',4,'1',0),(26,'链表的定义','<div id=\"arc-body\">线性存储结构——<span style=\"color:#008000;\">链表</span>。<br>\r\n<br>\r\n链表，别名<span style=\"color:#008000;\">链式存储结构</span>或<span style=\"color:#008000;\">单链表</span>，用于存储逻辑关系为 \"一对一\" 的数据。<span style=\"color:#b22222;\">与<u><a href=\"/view/158.html\" target=\"_blank\">顺序表</a></u>不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。</span><br>\r\n<br>\r\n例如，使用链表存储 <code>{1,2,3}</code>，数据的物理存储状态如<u><a href=\"/view/200.html\" target=\"_blank\">图</a></u> 1 所示：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"链表随机存储数据\" src=\"http://data.biancheng.net/uploads/allimg/181123/2-1Q12321231CA.gif\"><br>\r\n图 1 链表随机存储数据</div>\r\n<br>\r\n我们看到，图 1 根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如图 2 所示：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"各数据元素配备指针\" src=\"http://data.biancheng.net/uploads/allimg/181123/2-1Q12321243O36.gif\"><br>\r\n图 2 各数据元素配备指针</div>\r\n<br>\r\n像图 2 这样，<span style=\"color:#b22222;\">数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是</span><span style=\"color:#008000;\">链式存储结构</span>。<br>\r\n<h2>\r\n链表的节点</h2>\r\n从图 2 可以看到，链表中每个数据的存储都由以下两部分组成：\r\n<ol>\r\n<li>\r\n数据元素本身，其所在的区域称为<span style=\"color:#008000;\">数据域</span>；</li>\r\n<li>\r\n指向直接后继元素的指针，所在的区域称为<span style=\"color:#008000;\">指针域</span>；</li>\r\n</ol>\r\n<br>\r\n即链表中存储各数据元素的结构如图 3 所示：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"\" src=\"http://data.biancheng.net/uploads/allimg/181123/2-1Q1232126112G.gif\"><br>\r\n图 3 节点结构</div>\r\n<br>\r\n图 3 所示的结构在链表中称为<span style=\"color:#008000;\">节点</span>。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"链表中的节点\" src=\"http://data.biancheng.net/uploads/allimg/181123/2-1Q123212Q3337.gif\"><br>\r\n图 4 链表中的节点</div>\r\n<br>\r\n因此，链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：<br>\r\n<div class=\"snippet-container\" style=\"undefined;\"><div class=\"sh_bright snippet-wrap\"><div class=\"snippet-menu sh_sourceCode\" style=\"display:none;\"><pre><a class=\"snippet-copy sh_url\" href=\"#\" style=\"display: none;\">复制</a><a class=\"snippet-text sh_url\" href=\"#\">纯文本</a><a class=\"snippet-window sh_url\" href=\"#\">复制</a></pre></div><pre class=\"cpp sh_cpp snippet-formatted sh_sourceCode\"><ol class=\"snippet-num\"><li><span class=\"sh_keyword\">typedef</span> <span class=\"sh_keyword\">struct</span><span class=\"sh_normal\"> </span><span class=\"sh_classname\">Link</span><span class=\"sh_cbracket\">{</span></li><li>    <span class=\"sh_type\">char</span> elem<span class=\"sh_symbol\">;</span> <span class=\"sh_comment\">//代表数据域</span></li><li>    <span class=\"sh_keyword\">struct</span><span class=\"sh_normal\"> </span><span class=\"sh_classname\">Link</span> <span class=\"sh_symbol\">*</span> next<span class=\"sh_symbol\">;</span> <span class=\"sh_comment\">//代表指针域，指向直接后继元素</span></li><li><span class=\"sh_cbracket\">}</span>link<span class=\"sh_symbol\">;</span> <span class=\"sh_comment\">//link为节点名，每个节点都是一个 link 结构体</span></li></ol></pre><pre class=\"snippet-textonly sh_sourceCode\" style=\"display:none;\">typedef struct Link{\r\n    char elem; //代表数据域\r\n    struct Link * next; //代表指针域，指向直接后继元素\r\n}link; //link为节点名，每个节点都是一个 link 结构体</pre></div></div>\r\n提示，由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 <code>struct Link*</code> 的形式）。<br>\r\n<h2>\r\n头节点，头指针和首元节点</h2>\r\n其实，图 4 所示的链表结构并不完整。一个完整的链表需要由以下几部分构成：\r\n<ol>\r\n<li>\r\n<span style=\"color:#008000;\">头指针</span>：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</li>\r\n<li>\r\n<span style=\"color:#008000;\">节点</span>：链表中的节点又细分为<span style=\"color:#008000;\">头节点</span>、<span style=\"color:#008000;\">首元节点</span>和其他节点：\r\n<ul>\r\n<li>\r\n<span style=\"color:#008000;\">头节点</span>：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；</li>\r\n<li>\r\n<span style=\"color:#008000;\">首元节点</span>：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</li>\r\n<li>\r\n其他节点：链表中其他的节点；</li>\r\n</ul>\r\n</li>\r\n</ol>\r\n<br>\r\n因此，一个存储 <code>{1,2,3}</code> 的完整链表结构如图 5 所示：\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"完整的链表示意图\" src=\"http://data.biancheng.net/uploads/allimg/181123/2-1Q123213124343.gif\"><br>\r\n图 5 完整的链表示意图</div>\r\n<p class=\"info-box\">\r\n<span style=\"color:#b22222;\">注意</span>：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。</p>\r\n明白了链表的基本结构，下面我们来学习如何创建一个链表。<br>\r\n<h2>\r\n链表的创建（初始化）</h2>\r\n创建一个链表需要做如下工作：\r\n<ol>\r\n<li>\r\n声明一个头指针（如果有必要，可以声明一个头节点）；</li>\r\n<li>\r\n创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；</li>\r\n</ol>\r\n<br>\r\n例如，创建一个存储 <code>{1,2,3,4}</code> 且无头节点的链表，C 语言实现代码如下：\r\n<div class=\"snippet-container\" style=\"undefined;\"><div class=\"sh_bright snippet-wrap\"><div class=\"snippet-menu sh_sourceCode\" style=\"display:none;\"><pre><a class=\"snippet-copy sh_url\" href=\"#\" style=\"display: none;\">复制</a><a class=\"snippet-text sh_url\" href=\"#\">纯文本</a><a class=\"snippet-window sh_url\" href=\"#\">复制</a></pre></div><pre class=\"cpp sh_cpp snippet-formatted sh_sourceCode\"><ol class=\"snippet-num\"><li>link <span class=\"sh_symbol\">*</span> <span class=\"sh_function\">initLink</span><span class=\"sh_symbol\">()</span> <span class=\"sh_cbracket\">{</span></li><li>    <span class=\"sh_type\">int</span> i<span class=\"sh_symbol\">;</span></li><li>    link <span class=\"sh_symbol\">*</span> p <span class=\"sh_symbol\">=</span> NULL<span class=\"sh_symbol\">;</span><span class=\"sh_comment\">//创建头指针</span></li><li>    link <span class=\"sh_symbol\">*</span> temp <span class=\"sh_symbol\">=</span> <span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">*)</span><span class=\"sh_function\">malloc</span><span class=\"sh_symbol\">(</span><span class=\"sh_keyword\">sizeof</span><span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">));</span><span class=\"sh_comment\">//创建首元节点</span></li><li>    <span class=\"sh_comment\">//首元节点先初始化</span></li><li>    temp<span class=\"sh_symbol\">-&gt;</span>elem <span class=\"sh_symbol\">=</span> <span class=\"sh_number\">1</span><span class=\"sh_symbol\">;</span></li><li>    temp<span class=\"sh_symbol\">-&gt;</span>next <span class=\"sh_symbol\">=</span> NULL<span class=\"sh_symbol\">;</span></li><li>    p <span class=\"sh_symbol\">=</span> temp<span class=\"sh_symbol\">;</span><span class=\"sh_comment\">//头指针指向首元节点</span></li><li>    <span class=\"sh_comment\">//从第二个节点开始创建</span></li><li>    <span class=\"sh_keyword\">for</span> <span class=\"sh_symbol\">(</span>i <span class=\"sh_symbol\">=</span> <span class=\"sh_number\">2</span><span class=\"sh_symbol\">;</span> i <span class=\"sh_symbol\">&lt;</span> <span class=\"sh_number\">5</span><span class=\"sh_symbol\">;</span> i<span class=\"sh_symbol\">++)</span> <span class=\"sh_cbracket\">{</span></li><li>        <span class=\"sh_comment\">//创建一个新节点并初始化</span></li><li>        <span class=\"sh_usertype\">link</span><span class=\"sh_normal\"> </span><span class=\"sh_symbol\">*</span>a <span class=\"sh_symbol\">=</span> <span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">*)</span><span class=\"sh_function\">malloc</span><span class=\"sh_symbol\">(</span><span class=\"sh_keyword\">sizeof</span><span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">));</span></li><li>        a<span class=\"sh_symbol\">-&gt;</span>elem <span class=\"sh_symbol\">=</span> i<span class=\"sh_symbol\">;</span></li><li>        a<span class=\"sh_symbol\">-&gt;</span>next <span class=\"sh_symbol\">=</span> NULL<span class=\"sh_symbol\">;</span></li><li>        <span class=\"sh_comment\">//将temp节点与新建立的a节点建立逻辑关系</span></li><li>        temp<span class=\"sh_symbol\">-&gt;</span>next <span class=\"sh_symbol\">=</span> a<span class=\"sh_symbol\">;</span></li><li>        <span class=\"sh_comment\">//指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对</span></li><li>        temp <span class=\"sh_symbol\">=</span> temp<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">;</span></li><li>    <span class=\"sh_cbracket\">}</span></li><li>    <span class=\"sh_comment\">//返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表</span></li><li>    <span class=\"sh_keyword\">return</span> p<span class=\"sh_symbol\">;</span></li><li><span class=\"sh_cbracket\">}</span></li></ol></pre><pre class=\"snippet-textonly sh_sourceCode\" style=\"display:none;\">link * initLink() {\r\n    int i;\r\n    link * p = NULL;//创建头指针\r\n    link * temp = (link*)malloc(sizeof(link));//创建首元节点\r\n    //首元节点先初始化\r\n    temp-&gt;elem = 1;\r\n    temp-&gt;next = NULL;\r\n    p = temp;//头指针指向首元节点\r\n    //从第二个节点开始创建\r\n    for (i = 2; i &lt; 5; i++) {\r\n        //创建一个新节点并初始化\r\n        link *a = (link*)malloc(sizeof(link));\r\n        a-&gt;elem = i;\r\n        a-&gt;next = NULL;\r\n        //将temp节点与新建立的a节点建立逻辑关系\r\n        temp-&gt;next = a;\r\n        //指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对\r\n        temp = temp-&gt;next;\r\n    }\r\n    //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表\r\n    return p;\r\n}</pre></div></div>\r\n如果想创建一个存储 <code>{1,2,3,4}</code> 且含头节点的链表，则 C 语言实现代码为：\r\n<div class=\"snippet-container\" style=\"undefined;\"><div class=\"sh_bright snippet-wrap\"><div class=\"snippet-menu sh_sourceCode\" style=\"display:none;\"><pre><a class=\"snippet-copy sh_url\" href=\"#\" style=\"display: none;\">复制</a><a class=\"snippet-text sh_url\" href=\"#\">纯文本</a><a class=\"snippet-window sh_url\" href=\"#\">复制</a></pre></div><pre class=\"cpp sh_cpp snippet-formatted sh_sourceCode\"><ol class=\"snippet-num\"><li>link <span class=\"sh_symbol\">*</span> <span class=\"sh_function\">initLink</span><span class=\"sh_symbol\">()</span><span class=\"sh_cbracket\">{</span></li><li>    <span class=\"sh_type\">int</span> i<span class=\"sh_symbol\">;</span></li><li>    link <span class=\"sh_symbol\">*</span> p<span class=\"sh_symbol\">=(</span>link<span class=\"sh_symbol\">*)</span><span class=\"sh_function\">malloc</span><span class=\"sh_symbol\">(</span><span class=\"sh_keyword\">sizeof</span><span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">));</span><span class=\"sh_comment\">//创建一个头结点</span></li><li>    link <span class=\"sh_symbol\">*</span> temp<span class=\"sh_symbol\">=</span>p<span class=\"sh_symbol\">;</span><span class=\"sh_comment\">//声明一个指针指向头结点，</span></li><li>    <span class=\"sh_comment\">//生成链表</span></li><li>    <span class=\"sh_keyword\">for</span> <span class=\"sh_symbol\">(</span>i<span class=\"sh_symbol\">=</span><span class=\"sh_number\">1</span><span class=\"sh_symbol\">;</span> i<span class=\"sh_symbol\">&lt;</span><span class=\"sh_number\">5</span><span class=\"sh_symbol\">;</span> i<span class=\"sh_symbol\">++)</span> <span class=\"sh_cbracket\">{</span></li><li>        <span class=\"sh_usertype\">link</span><span class=\"sh_normal\"> </span><span class=\"sh_symbol\">*</span>a<span class=\"sh_symbol\">=(</span>link<span class=\"sh_symbol\">*)</span><span class=\"sh_function\">malloc</span><span class=\"sh_symbol\">(</span><span class=\"sh_keyword\">sizeof</span><span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">));</span></li><li>        a<span class=\"sh_symbol\">-&gt;</span>elem<span class=\"sh_symbol\">=</span>i<span class=\"sh_symbol\">;</span></li><li>        a<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">=</span>NULL<span class=\"sh_symbol\">;</span></li><li>        temp<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">=</span>a<span class=\"sh_symbol\">;</span></li><li>        temp<span class=\"sh_symbol\">=</span>temp<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">;</span></li><li>    <span class=\"sh_cbracket\">}</span></li><li>    <span class=\"sh_keyword\">return</span> p<span class=\"sh_symbol\">;</span></li><li><span class=\"sh_cbracket\">}</span></li></ol></pre><pre class=\"snippet-textonly sh_sourceCode\" style=\"display:none;\">link * initLink(){\r\n    int i;\r\n    link * p=(link*)malloc(sizeof(link));//创建一个头结点\r\n    link * temp=p;//声明一个指针指向头结点，\r\n    //生成链表\r\n    for (i=1; i&lt;5; i++) {\r\n        link *a=(link*)malloc(sizeof(link));\r\n        a-&gt;elem=i;\r\n        a-&gt;next=NULL;\r\n        temp-&gt;next=a;\r\n        temp=temp-&gt;next;\r\n    }\r\n    return p;\r\n}</pre></div></div>\r\n<br>\r\n我们只需在主函数中调用 initLink 函数，即可轻松创建一个存储 <code>{1,2,3,4}</code> 的链表，C 语言完整代码如下：\r\n<div class=\"snippet-container\" style=\"undefined;\"><div class=\"sh_bright snippet-wrap\"><div class=\"snippet-menu sh_sourceCode\" style=\"display: none;\"><pre><a class=\"snippet-copy sh_url\" href=\"#\" style=\"display: none;\">复制</a><a class=\"snippet-text sh_url\" href=\"#\">纯文本</a><a class=\"snippet-window sh_url\" href=\"#\">复制</a></pre></div><pre class=\"cpp sh_cpp snippet-formatted sh_sourceCode\"><ol class=\"snippet-num\"><li><span class=\"sh_preproc\">#include</span> <span class=\"sh_string\">&lt;stdio.h&gt;</span></li><li><span class=\"sh_preproc\">#include</span> <span class=\"sh_string\">&lt;stdlib.h&gt;</span></li><li><span class=\"sh_comment\">//链表中节点的结构</span></li><li><span class=\"sh_keyword\">typedef</span> <span class=\"sh_keyword\">struct</span><span class=\"sh_normal\"> </span><span class=\"sh_classname\">Link</span> <span class=\"sh_cbracket\">{</span></li><li>    <span class=\"sh_type\">int</span>  elem<span class=\"sh_symbol\">;</span></li><li>    <span class=\"sh_keyword\">struct</span><span class=\"sh_normal\"> </span><span class=\"sh_classname\">Link</span> <span class=\"sh_symbol\">*</span>next<span class=\"sh_symbol\">;</span></li><li><span class=\"sh_cbracket\">}</span>link<span class=\"sh_symbol\">;</span></li><li><span class=\"sh_comment\">//初始化链表的函数</span></li><li>link <span class=\"sh_symbol\">*</span> <span class=\"sh_function\">initLink</span><span class=\"sh_symbol\">();</span></li><li><span class=\"sh_comment\">//用于输出链表的函数</span></li><li><span class=\"sh_type\">void</span> <span class=\"sh_function\">display</span><span class=\"sh_symbol\">(</span><span class=\"sh_usertype\">link</span><span class=\"sh_normal\"> </span><span class=\"sh_symbol\">*</span>p<span class=\"sh_symbol\">);</span></li><li><span style=\"display:none;\">&nbsp;</span></li><li><span class=\"sh_type\">int</span> <span class=\"sh_function\">main</span><span class=\"sh_symbol\">()</span> <span class=\"sh_cbracket\">{</span></li><li>    link<span class=\"sh_symbol\">*</span>p <span class=\"sh_symbol\">=</span> NULL<span class=\"sh_symbol\">;</span></li><li>    <span class=\"sh_comment\">//初始化链表（1，2，3，4）</span></li><li>    <span class=\"sh_function\">printf</span><span class=\"sh_symbol\">(</span><span class=\"sh_string\">\"初始化链表为：</span><span class=\"sh_specialchar\">\\n</span><span class=\"sh_string\">\"</span><span class=\"sh_symbol\">);</span></li><li>    p <span class=\"sh_symbol\">=</span> <span class=\"sh_function\">initLink</span><span class=\"sh_symbol\">();</span></li><li>    <span class=\"sh_function\">display</span><span class=\"sh_symbol\">(</span>p<span class=\"sh_symbol\">);</span></li><li>    <span class=\"sh_keyword\">return</span> <span class=\"sh_number\">0</span><span class=\"sh_symbol\">;</span></li><li><span class=\"sh_cbracket\">}</span></li><li><span style=\"display:none;\">&nbsp;</span></li><li>link <span class=\"sh_symbol\">*</span> <span class=\"sh_function\">initLink</span><span class=\"sh_symbol\">()</span> <span class=\"sh_cbracket\">{</span></li><li>    <span class=\"sh_type\">int</span> i<span class=\"sh_symbol\">;</span></li><li>    link <span class=\"sh_symbol\">*</span> p <span class=\"sh_symbol\">=</span> NULL<span class=\"sh_symbol\">;</span><span class=\"sh_comment\">//创建头指针</span></li><li>    link <span class=\"sh_symbol\">*</span> temp <span class=\"sh_symbol\">=</span> <span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">*)</span><span class=\"sh_function\">malloc</span><span class=\"sh_symbol\">(</span><span class=\"sh_keyword\">sizeof</span><span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">));</span><span class=\"sh_comment\">//创建首元节点</span></li><li>    <span class=\"sh_comment\">//首元节点先初始化</span></li><li>    temp<span class=\"sh_symbol\">-&gt;</span>elem <span class=\"sh_symbol\">=</span> <span class=\"sh_number\">1</span><span class=\"sh_symbol\">;</span></li><li>    temp<span class=\"sh_symbol\">-&gt;</span>next <span class=\"sh_symbol\">=</span> NULL<span class=\"sh_symbol\">;</span></li><li>    p <span class=\"sh_symbol\">=</span> temp<span class=\"sh_symbol\">;</span><span class=\"sh_comment\">//头指针指向首元节点</span></li><li>    <span class=\"sh_keyword\">for</span> <span class=\"sh_symbol\">(</span>i <span class=\"sh_symbol\">=</span> <span class=\"sh_number\">2</span><span class=\"sh_symbol\">;</span> i <span class=\"sh_symbol\">&lt;</span> <span class=\"sh_number\">5</span><span class=\"sh_symbol\">;</span> i<span class=\"sh_symbol\">++)</span> <span class=\"sh_cbracket\">{</span></li><li>        <span class=\"sh_usertype\">link</span><span class=\"sh_normal\"> </span><span class=\"sh_symbol\">*</span>a <span class=\"sh_symbol\">=</span> <span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">*)</span><span class=\"sh_function\">malloc</span><span class=\"sh_symbol\">(</span><span class=\"sh_keyword\">sizeof</span><span class=\"sh_symbol\">(</span>link<span class=\"sh_symbol\">));</span></li><li>        a<span class=\"sh_symbol\">-&gt;</span>elem <span class=\"sh_symbol\">=</span> i<span class=\"sh_symbol\">;</span></li><li>        a<span class=\"sh_symbol\">-&gt;</span>next <span class=\"sh_symbol\">=</span> NULL<span class=\"sh_symbol\">;</span></li><li>        temp<span class=\"sh_symbol\">-&gt;</span>next <span class=\"sh_symbol\">=</span> a<span class=\"sh_symbol\">;</span></li><li>        temp <span class=\"sh_symbol\">=</span> temp<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">;</span></li><li>    <span class=\"sh_cbracket\">}</span></li><li>    <span class=\"sh_keyword\">return</span> p<span class=\"sh_symbol\">;</span></li><li><span class=\"sh_cbracket\">}</span></li><li><span class=\"sh_type\">void</span> <span class=\"sh_function\">display</span><span class=\"sh_symbol\">(</span><span class=\"sh_usertype\">link</span><span class=\"sh_normal\"> </span><span class=\"sh_symbol\">*</span>p<span class=\"sh_symbol\">)</span> <span class=\"sh_cbracket\">{</span></li><li>    link<span class=\"sh_symbol\">*</span> temp <span class=\"sh_symbol\">=</span> p<span class=\"sh_symbol\">;</span><span class=\"sh_comment\">//将temp指针重新指向头结点</span></li><li>    <span class=\"sh_comment\">//只要temp指针指向的结点的next不是Null，就执行输出语句。</span></li><li>    <span class=\"sh_keyword\">while</span> <span class=\"sh_symbol\">(</span>temp<span class=\"sh_symbol\">)</span> <span class=\"sh_cbracket\">{</span></li><li>        <span class=\"sh_function\">printf</span><span class=\"sh_symbol\">(</span><span class=\"sh_string\">\"%d \"</span><span class=\"sh_symbol\">,</span> temp<span class=\"sh_symbol\">-&gt;</span>elem<span class=\"sh_symbol\">);</span></li><li>        temp <span class=\"sh_symbol\">=</span> temp<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">;</span></li><li>    <span class=\"sh_cbracket\">}</span></li><li>    <span class=\"sh_function\">printf</span><span class=\"sh_symbol\">(</span><span class=\"sh_string\">\"</span><span class=\"sh_specialchar\">\\n</span><span class=\"sh_string\">\"</span><span class=\"sh_symbol\">);</span></li><li><span class=\"sh_cbracket\">}</span></li></ol></pre><pre class=\"snippet-textonly sh_sourceCode\" style=\"display:none;\">#include &lt;stdio.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n//链表中节点的结构\r\ntypedef struct Link {\r\n    int  elem;\r\n    struct Link *next;\r\n}link;\r\n//初始化链表的函数\r\nlink * initLink();\r\n//用于输出链表的函数\r\nvoid display(link *p);\r\n\r\nint main() {\r\n    link*p = NULL;\r\n    //初始化链表（1，2，3，4）\r\n    printf(\"初始化链表为：\\n\");\r\n    p = initLink();\r\n    display(p);\r\n    return 0;\r\n}\r\n\r\nlink * initLink() {\r\n    int i;\r\n    link * p = NULL;//创建头指针\r\n    link * temp = (link*)malloc(sizeof(link));//创建首元节点\r\n    //首元节点先初始化\r\n    temp-&gt;elem = 1;\r\n    temp-&gt;next = NULL;\r\n    p = temp;//头指针指向首元节点\r\n    for (i = 2; i &lt; 5; i++) {\r\n        link *a = (link*)malloc(sizeof(link));\r\n        a-&gt;elem = i;\r\n        a-&gt;next = NULL;\r\n        temp-&gt;next = a;\r\n        temp = temp-&gt;next;\r\n    }\r\n    return p;\r\n}\r\nvoid display(link *p) {\r\n    link* temp = p;//将temp指针重新指向头结点\r\n    //只要temp指针指向的结点的next不是Null，就执行输出语句。\r\n    while (temp) {\r\n        printf(\"%d \", temp-&gt;elem);\r\n        temp = temp-&gt;next;\r\n    }\r\n    printf(\"\\n\");\r\n}</pre></div></div>\r\n程序运行结果为：\r\n<p class=\"info-box\">\r\n初始化链表为：<br>\r\n1 2 3 4</p>\r\n<br>\r\n注意，如果使用带有头节点创建链表的方式，则输出链表的 display 函数需要做适当地修改：\r\n<div class=\"snippet-container\" style=\"undefined;\"><div class=\"sh_bright snippet-wrap\"><div class=\"snippet-menu sh_sourceCode\" style=\"display: none;\"><pre><a class=\"snippet-copy sh_url\" href=\"#\" style=\"display: none;\">复制</a><a class=\"snippet-text sh_url\" href=\"#\">纯文本</a><a class=\"snippet-window sh_url\" href=\"#\">复制</a></pre></div><pre class=\"cpp sh_cpp snippet-formatted sh_sourceCode\"><ol class=\"snippet-num\"><li><span class=\"sh_type\">void</span> <span class=\"sh_function\">display</span><span class=\"sh_symbol\">(</span><span class=\"sh_usertype\">link</span><span class=\"sh_normal\"> </span><span class=\"sh_symbol\">*</span>p<span class=\"sh_symbol\">)</span><span class=\"sh_cbracket\">{</span></li><li>    link<span class=\"sh_symbol\">*</span> temp<span class=\"sh_symbol\">=</span>p<span class=\"sh_symbol\">;</span><span class=\"sh_comment\">//将temp指针重新指向头结点</span></li><li>    <span class=\"sh_comment\">//只要temp指针指向的结点的next不是Null，就执行输出语句。</span></li><li>    <span class=\"sh_keyword\">while</span> <span class=\"sh_symbol\">(</span>temp<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">)</span> <span class=\"sh_cbracket\">{</span></li><li>        temp<span class=\"sh_symbol\">=</span>temp<span class=\"sh_symbol\">-&gt;</span>next<span class=\"sh_symbol\">;</span></li><li>        <span class=\"sh_function\">printf</span><span class=\"sh_symbol\">(</span><span class=\"sh_string\">\"%d\"</span><span class=\"sh_symbol\">,</span>temp<span class=\"sh_symbol\">-&gt;</span>elem<span class=\"sh_symbol\">);</span></li><li>    <span class=\"sh_cbracket\">}</span></li><li>    <span class=\"sh_function\">printf</span><span class=\"sh_symbol\">(</span><span class=\"sh_string\">\"</span><span class=\"sh_specialchar\">\\n</span><span class=\"sh_string\">\"</span><span class=\"sh_symbol\">);</span></li><li><span class=\"sh_cbracket\">}</span></li></ol></pre><pre class=\"snippet-textonly sh_sourceCode\" style=\"display:none;\">void display(link *p){\r\n    link* temp=p;//将temp指针重新指向头结点\r\n    //只要temp指针指向的结点的next不是Null，就执行输出语句。\r\n    while (temp-&gt;next) {\r\n        temp=temp-&gt;next;\r\n        printf(\"%d\",temp-&gt;elem);\r\n    }\r\n    printf(\"\\n\");\r\n}</pre></div></div>\r\n</div>',5,'2',25),(27,'队列的定义','<div id=\"arc-body\"><span style=\"color:#008000;\">队列</span>是一种对数据的\"存\"和\"取\"有严格要求的线性存储结构。<br>\r\n<br>\r\n与栈结构不同的是，<span style=\"color:#b22222;\">队列的两端都\"开口\"，要求数据只能从一端进，从另一端出</span>，如<u><a href=\"/view/200.html\" target=\"_blank\">图</a></u> 1 所示：<br>\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"队列存储结构\" src=\"http://data.biancheng.net/uploads/allimg/181203/2-1Q203200556309.gif\"><br>\r\n图 1 队列存储结构</div>\r\n<p class=\"info-box\">\r\n通常，称进数据的一端为 \"<span style=\"color:#008000;\">队尾</span>\"，出数据的一端为 \"<span style=\"color:#008000;\">队头</span>\"，数据元素进队列的过程称为 \"<span style=\"color:#008000;\">入队</span>\"，出队列的过程称为 \"<span style=\"color:#008000;\">出队</span>\"。</p>\r\n不仅如此，<span style=\"color:#b22222;\">队列中数据的进出要遵循 \"先进先出\" 的原则</span>，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 \"先进先出\" 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。<br>\r\n<p class=\"info-box\">\r\n栈和队列不要混淆，栈结构是一端封口，特点是\"先进后出\"；而队列的两端全是开口，特点是\"先进先出\"。</p>\r\n因此，数据从表的一端进，从另一端出，且遵循 \"先进先出\" 原则的线性存储结构就是队列。<br>\r\n<h2>\r\n队列的实现</h2>\r\n队列存储结构的实现有以下两种方式：\r\n<ol>\r\n<li>\r\n<span style=\"color:#008000;\"><u><a href=\"/view/173.html\" target=\"_blank\">顺序队列</a></u></span>：在<u><a href=\"/view/158.html\" target=\"_blank\">顺序表</a></u>的基础上实现的队列结构；</li>\r\n<li>\r\n<span style=\"color:#008000;\"><u><a href=\"/view/174.html\" target=\"_blank\">链队列</a></u></span>：在<u><a href=\"/view/160.html\" target=\"_blank\">链表</a></u>的基础上实现的队列结构；</li>\r\n</ol>\r\n<br>\r\n两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。<br>\r\n<h2>\r\n队列的实际应用</h2>\r\n实际生活中，队列的应用随处可见，比如排队买 XXX、医院的挂号系统等，采用的都是队列的结构。<br>\r\n<br>\r\n拿排队买票来说，所有的人排成一队，先到者排的就靠前，后到者只能从队尾排队等待，队中的每个人都必须等到自己前面的所有人全部买票成功并从队头出队后，才轮到自己买票。这就不是典型的队列结构吗？<br>\r\n<br>\r\n明白了什么是队列，接下来开始系统地学习顺序队列和链队列。<br>\r\n</div>',6,'2',25),(28,'栈的定义','<div id=\"arc-body\"><span style=\"color:#008000;\">栈</span><span style=\"color:#b22222;\">也是用来存储逻辑关系为 \"一对一\" 数据的线性存储结构，如<u><a href=\"/view/200.html\" target=\"_blank\">图</a></u> 1 所示。</span>\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"栈存储结构示意图\" src=\"http://data.biancheng.net/uploads/allimg/181201/2-1Q201203Q5110.gif\"><br>\r\n图 1 栈存储结构示意图</div>\r\n<br>\r\n从图 1 我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 \"存\" 和 \"取\" 的过程有特殊的要求：\r\n<ol>\r\n<li>\r\n栈只能从表的一端存取数据，另一端是封闭的，如图 1 所示；</li>\r\n<li>\r\n在栈中，无论是存数据还是取数据，都必须遵循\"先进后出\"的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据\"先进后出\"的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。</li>\r\n</ol>\r\n<br>\r\n因此，我们可以给栈下一个定义，即<span style=\"color:#b22222;\">栈是一种只能从表的一端存取数据且遵循 \"先进后出\" 原则的线性存储结构。</span><br>\r\n<br>\r\n通常，栈的开口端被称为<span style=\"color:#008000;\">栈顶</span>；相应地，封口端被称为<span style=\"color:#008000;\">栈底</span>。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"栈顶和栈底\" src=\"http://data.biancheng.net/uploads/allimg/181201/2-1Q201204153P8.gif\"><br>\r\n图 2 栈顶和栈底</div>\r\n<h2>\r\n进栈和出栈</h2>\r\n基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：\r\n<ul>\r\n<li>\r\n向栈中添加元素，此过程被称为\"<span style=\"color:#008000;\">进栈</span>\"（<span style=\"color:#008000;\">入栈</span>或<span style=\"color:#008000;\">压栈</span>）；</li>\r\n<li>\r\n从栈中提取出指定元素，此过程被称为\"<span style=\"color:#008000;\">出栈</span>\"（或<span style=\"color:#008000;\">弹栈</span>）；</li>\r\n</ul>\r\n<h2>\r\n栈的具体实现</h2>\r\n栈是一种 \"特殊\" 的线性存储结构，因此栈的具体实现有以下两种方式：\r\n<ol>\r\n<li>\r\n<span style=\"color:#008000;\"><u><a href=\"/view/170.html\" target=\"_blank\">顺序栈</a></u></span>：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；</li>\r\n<li>\r\n<span style=\"color:#008000;\"><u><a href=\"/view/171.html\" target=\"_blank\">链栈</a></u></span>：采用链式存储结构实现栈结构；</li>\r\n</ol>\r\n<p class=\"info-box\">\r\n两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是<u><a href=\"/view/181.html\" target=\"_blank\">数组</a></u>，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。</p>\r\n<h2>\r\n栈的应用</h2>\r\n基于栈结构对数据存取采用 \"先进后出\" 原则的特点，它可以用于实现很多功能。<br>\r\n<br>\r\n例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：\r\n<ul>\r\n<li>\r\n重新搜索找到页面 A；</li>\r\n<li>\r\n使用浏览器的\"回退\"功能。浏览器会先回退到页面 B，而后再回退到页面 A。</li>\r\n</ul>\r\n<br>\r\n浏览器 \"回退\" 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。<br>\r\n<br>\r\n不仅如此，栈存储结构还可以帮我们检测代码中的<a href=\"/view/87.html\" target=\"_blank\">括号匹配</a>问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。<br>\r\n<br>\r\n同时，栈结构还可以实现数值的<a href=\"/view/86.html\" target=\"_blank\">进制转换</a>功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。<br>\r\n<br>\r\n以上也仅是栈应用领域的冰山一角，这里不再过多举例。在后续章节的学习中，我们会大量使用到栈结构。<br>\r\n<br>\r\n接下来，我们学习如何实现顺序栈和链栈，以及对栈中元素进行入栈和出栈的操作。<br>\r\n</div>',7,'2',25),(29,'数组','<div id=\"arc-body\">前面学习数据结构的过程中，总是使用数组作为<u><a href=\"/view/158.html\" target=\"_blank\">顺序表</a></u>的底层实现，给我们一种 \"数据结构中，数组的作用就是实现顺序表\" 的错误认识。其实，数组的作用远不止于此。<br>\r\n<br>\r\n本节将从数据结构的角度讲解<span style=\"color:#b22222;\">数组存储结构</span>。<br>\r\n<p class=\"info-box\">\r\n本节所讲的数组，要将其视为一种存储结构，与平时使用的数组基本数据类型区分开。</p>\r\n<h2>\r\n什么是数组</h2>\r\n一说起数组，我们的印象中数组往往是某一门编程语言中包含的具体数据类型，其实不然。<br>\r\n<br>\r\n从本质上讲，数组与顺序表、<u><a href=\"/view/160.html\" target=\"_blank\">链表</a></u>、<u><a href=\"/view/169.html\" target=\"_blank\">栈</a></u>和<u><a href=\"/view/172.html\" target=\"_blank\">队列</a></u>一样，都用来存储具有 \"一对一\" 逻辑关系数据的线性存储结构。只因各编程语言都默认将数组作为基本数据类型，使初学者对数组有了 \"只是基本数据类型，不是存储结构\" 的误解。<br>\r\n<br>\r\n不仅如此，数组和其他线性存储结构不同，顺序表、链表、栈和队列存储的都是不可再分的数据元素（如数字 5、字符 \'a\' 等），而数组既可以用来存储不可再分的数据元素，也可以用来存储像顺序表、链表这样的数据结构。<br>\r\n<br>\r\n比如说，数组可以直接存储多个顺序表。我们知道，顺序表的底层实现还是数组，因此等价于数组中继续存储数组。这与平时使用的二维数组类似。<br>\r\n<br>\r\n根据数组中存储数据之间逻辑结构的不同，数组可细分为一维数组、二维数组、...、n 维数组：\r\n<ul>\r\n<li>\r\n一维数组，指的是存储不可再分数据元素的数组，如<u><a href=\"/view/200.html\" target=\"_blank\">图</a></u> 1 所示；\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"一维数组存储结构示意图\" src=\"/uploads/allimg/181214/2-1Q21419542I92.gif\"><br>\r\n图 1 一维数组存储结构示意图<br>\r\n&nbsp;</div>\r\n</li>\r\n<li>\r\n二维数组，指的存储一维数组的一维数组，如图 2 所示；<br>\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"二维数组存储结构示意图\" src=\"/uploads/allimg/181214/2-1Q214195P0Z9.gif\"><br>\r\n图 2 二维数组存储结构示意图<br>\r\n&nbsp;</div>\r\n</li>\r\n<li>\r\nn 维数组，指的是存储 n-1 维数组的一维数组；</li>\r\n</ul>\r\n<p class=\"info-box\">\r\n注意，无论数组的维数是多少，数组中的数据类型都必须一致。</p>\r\n由此，我们可以得出这样一个结论，一维数组结构是<u><a href=\"/view/157.html\" target=\"_blank\">线性表</a></u>的基本表现形式，而 n 维数组可理解为是对线性存储结构的一种扩展。</div>',8,'1',0),(30,'数组的定义','<div id=\"arc-body\">\r\n本节将从数据结构的角度讲解<span style=\"color:#b22222;\">数组存储结构</span>。<br>\r\n<p class=\"info-box\">\r\n本节所讲的数组，要将其视为一种存储结构，与平时使用的数组基本数据类型区分开。</p>\r\n<h2>\r\n什么是数组</h2>\r\n一说起数组，我们的印象中数组往往是某一门编程语言中包含的具体数据类型，其实不然。<br>\r\n<br>\r\n从本质上讲，数组与顺序表、<u><a href=\"/view/160.html\" target=\"_blank\">链表</a></u>、<u><a href=\"/view/169.html\" target=\"_blank\">栈</a></u>和<u><a href=\"/view/172.html\" target=\"_blank\">队列</a></u>一样，都用来存储具有 \"一对一\" 逻辑关系数据的线性存储结构。只因各编程语言都默认将数组作为基本数据类型，使初学者对数组有了 \"只是基本数据类型，不是存储结构\" 的误解。<br>\r\n<br>\r\n不仅如此，数组和其他线性存储结构不同，顺序表、链表、栈和队列存储的都是不可再分的数据元素（如数字 5、字符 \'a\' 等），而数组既可以用来存储不可再分的数据元素，也可以用来存储像顺序表、链表这样的数据结构。<br>\r\n<br>\r\n比如说，数组可以直接存储多个顺序表。我们知道，顺序表的底层实现还是数组，因此等价于数组中继续存储数组。这与平时使用的二维数组类似。<br>\r\n<br>\r\n根据数组中存储数据之间逻辑结构的不同，数组可细分为一维数组、二维数组、...、n 维数组：\r\n<ul>\r\n<li>\r\n一维数组，指的是存储不可再分数据元素的数组，如<u><a href=\"/view/200.html\" target=\"_blank\">图</a></u> 1 所示；\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"一维数组存储结构示意图\" src=\"http://data.biancheng.net/uploads/allimg/181214/2-1Q21419542I92.gif\"><br>\r\n图 1 一维数组存储结构示意图<br>\r\n&nbsp;</div>\r\n</li>\r\n<li>\r\n二维数组，指的存储一维数组的一维数组，如图 2 所示；<br>\r\n<div style=\"text-align: center;\">\r\n<br>\r\n<img alt=\"二维数组存储结构示意图\" src=\"http://data.biancheng.net/uploads/allimg/181214/2-1Q214195P0Z9.gif\"><br>\r\n图 2 二维数组存储结构示意图<br>\r\n&nbsp;</div>\r\n</li>\r\n<li>\r\nn 维数组，指的是存储 n-1 维数组的一维数组；</li>\r\n</ul>\r\n<p class=\"info-box\">\r\n注意，无论数组的维数是多少，数组中的数据类型都必须一致。</p>\r\n由此，我们可以得出这样一个结论，一维数组结构是<u><a href=\"/view/157.html\" target=\"_blank\">线性表</a></u>的基本表现形式，而 n 维数组可理解为是对线性存储结构的一种扩展。</div>',9,'2',29);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
